= Security =

== Introduction ==
In the previous sections, we addressed a lot of subjects related to microservices and Polycode. However, there is a very important aspect of all compute systems that we haven't talked about yet (or very little): security. In this section, I'm going to have a deeper look into securing our system, in a world where cyber-security attacks are done at a massive scale, and where malicious users and bad actors are more and more proactive.

=== What even is security ? ===
Security, in the context of a web application with a microservice backend, refers to a set of practices and technologies that are used to protect the application and its users from unauthorized access, data breaches, and other malicious activities.

Each deployed services has its own set of responsibilities and are ran in its own isolated environment. This architecture requires a different approach to security than a traditional monolithic application, as it requires coordination between multiple teams and a focus on securing individual services rather than the entire system. Security happens at multiple levels in our architecture:

* At the frontend
* At the backend
* At the operation level
* In the communication between all our actors

Security is not as simple as implementing something somewhere, and your system becomes secure. It requires an accurate understanding of how your system interacts. A team with a security mindset leads to a secure system, since every task, implementation, deployment and configuration have security concerns coming with it. Security should be a concern that every member working on a project should have. Security should be an integral part of the development and deployment process for any web application.

There is also no definitive way to have a 100% secure system. 0-risk doesn't exist, and it is important to realize that. With this fact in mind, the general objective changes. It becomes about reducing the surface of attack of your system, careful monitoring and auditing of your system and having well-defined incident response plan in case of an emergency.

=== Why is security important ? ===
Now that we have a better understanding about what security is, let's talk about why is security important. I'm going to assume that we are a company and not an educational project.

Security is important for several reasons:

* Protection of sensitive data: Security measures protects sensitive information, such as personal data, financial information, and confidential business information, from unauthorized access or breaches.
* Compliance: Many industries have regulations that require organizations to implement certain security measures to protect sensitive data, such as GDPR. Compliance with these regulations is important to avoid fines and reputational damage.
* Business continuity: Security measures helps making the organization's operations continuous in the event of a security incident. This includes disaster recovery plans, backups and other mechanisms to ensure the availability of systems and data.
* Protecting against cyber threats: Security measures help protect against cyber attacks, such as malware, which can cause data loss, system downtime, and more.
* Trust and reputation: Security is essential to building trust with customers, partners and stakeholders. It's important for organizations to be transparent about their security measures and to demonstrate that they take security seriously.
* Protecting intellectual property: Security measures help protect an organization's intellectual property, such as trade secrets, patents, trademarks or the codebase from theft or unauthorized use.

Let's get back in the context of Polycode. I'm going to talk about the biggest security concerns that we might encounter, categorized in 3 categories: frontend, backend and operation.

== Frontend security ==
Let's discuss security matters that relates to the frontend. When I talk about the frontend, I refer with the website that the user is going to interacts with, and how this website is interacting with our backend.

=== Cross-site scripting (XSS Attacks) ===
Cross-Site Scripting (XSS) attacks are a type of security vulnerability that allow attackers to inject malicious code into a web page viewed by other users. The malicious code, usually in the form of a script, is executed by the browser, allowing the attacker to steal sensitive information, such as user login credentials, or perform other malicious actions, such as redirecting the user to a phishing site.

There are two main types of XSS attacks:

* Stored XSS: where the attacker injects malicious code into a web page that is then stored on the server and served to all users who visit the page.
* Reflected XSS: where the attacker injects malicious code into a web page by tricking a user into clicking on a link or submitting a form that contains the code. The code is then reflected back to the user's browser and executed.

To prevent XSS attacks, you can:

* Validate input: Validate all user input to make sure that it does not contain any malicious code. Use a whitelist approach to only allow known good input, rather than trying to identify bad input. This should be applied where it makes sense, we don't want to invalidate Javascript code in our Javascript playgrounds.
* Encode output: Any user input that is displayed on a web page must be properly encoded to prevent the browser from interpreting it as code.
* Use content security policy (CSP): CSP is a security feature that helps prevent XSS attacks by specifying which sources of content are allowed to be loaded by the browser.
* Use `HttpOnly` cookies. This prevents any malicious Javascript from accessing the cookies set by the web page.

=== Cross-site Request Forgery (CSRF) ===
Cross-Site Request Forgery (CSRF) attacks tricks the user into performing an unintended action, such as transferring funds or changing their password, by tricking the user into clicking on a malicious link or submitting a form. The attacker takes advantage of the user's authenticated session with the web application to perform the action on the user's behalf.

Here are the main ways to prevent CSRF attacks:

* Use of anti-CSRF tokens: This is the most common method to prevent CSRF attacks. The server generates a unique token and sends it to the client as a hidden field in a form (hardly applies to us since we are using NextJS) or as a cookie. The token must then be included in any subsequent requests that modify data on the server.
* Same-site cookies: This is a browser-based security feature that prevents a web application from sending a user's cookies to a different site. This helps prevent an attacker from tricking the user into visiting a malicious site that then sends a request to the web application using the user's cookies.
* Use of the `referrer` header: This method involves checking the `referrer` header on the server to ensure that the request was made from the same site as the web application.

=== Browser storage attacks ===
Browser storage attacks occur when an attacker is able to exploit a vulnerability in the way that a web application stores data in the browser to gain access to sensitive data. The most common types of browser storage are cookies, local storage, session storage, and IndexedDB.

The main way to secure the data you store on the end user's user agent is to encrypt the data. This prevents an attacker from being able to read the data if they are able to access it. You should also regularly audit your code by reviewing it to make sure that data is stored and accessed securely and that sensitive data is not stored unnecessarily.

=== Man-in-the-middle attacks ===
Man-in-the-middle attacks are a category of attacks that can be performed to the data while it is transiting over the network. 

The most commons attacks are:

* Packet sniffing: an attacker listens to the packets transiting on the network, allowing him to steal credentials or perform replays attacks.
* Malicious code injection: an attack inject a malicious script to the website that is being visited, or can send its own phishing site altogether.

To prevent this kind of attacks, you should:

* Use an encrypted communication protocol (HTTPS), making it much more difficult to intercept and read the data in transit.
* Enable HTTP Strict Transport Security (HSTS): this technique allows a website to tell the browser that it should only be accessed over HTTPS and not HTTP. This prevents an attacker from intercepting a HTTPS connection and downgrading it to HTTP.
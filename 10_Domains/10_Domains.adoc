= From domains to microservices =

== Introduction ==
It's important to recognize the way you design you microservices will be reflected on the quality of your application. Poorly divided microservices will result in poor performance, poor maintainability, poor developer experience, and overall a bad user experience. If your data is poorly isolated, it will span multiple microservices and create a integrity and consistency mess. Make microservices too big and you lose the benefits. Make microservices too small and you begin to overload your network infrastructure, increase costs, decrease maintainability and increase your risks of bugs. Whatever your implementation, a poorly designed infrastructure will cause headaches. Let's see how we can create a sensible microservice architecture, using Polycode as our use case.

The first step in decomposing your application into microservices is to understand the domain that it lives in. To make sure that everybody is on the same page, and to provide a common vocabulary for your engineers, marketing team, executive team, architects and whoever might be working on the project, we need to define the language that is used around your project.

== Ubiquitous Language ==
The ubiquitous language is a common vocabulary everybody involved in the project should define together and use to communicate. The goal is to make sure that everybody refers to the same concept when talking about the project, reducing confusion and misunderstanding, avoiding conflicts and unnecessary discussion.

As the Polycode team, we defined the following vocabulary for the Polycode project. Please take some time to read through it, to make sure your understanding is aligned with mine.


|===
| Word | Definition 
| Practice | A section of Polycode made to train users 
| Assessment | A section of Polycode made to evaluate user 
| Admin | A privileged user that have access and permission to manage all resources in Polycode. 
| User | Someone who has a Polycode account. 
| Candidate | A person who participate to a test or assessment. 
| Guest | Someone who doesn't have an account. 
| Captain | A user who manages a team. 
| Assessment Creator | A user who can edit or create assessment, and invite candidates. 
| Practice Creator / Content creator | A user who can edit or create his content. 
| Test | It is an ordered group of contents made to evaluate users. It has a grade, which is the total score divided by the total number of points in the set of contents. It is created by an assessment creator. 
| Campaign | Usage of a test on a group of candidates 
| Module | A grouping, possibly nested, holding contents and that can give points when fully completed. 
| Content | A content is a coherent group of components. The contents are organized in a tree structure. The modules are branches and the contents are leaves. In other words, unlike modules, a content can't contain modules or other contents. 
| Component | Its a small unit of what will be displayed to the end users. You must use components to build your content, components compose contents. Can be of multiple types, a markdown or an editor for example. 
| Hint | A hint is an item to help the user to finish a component in exchange for PolyPoints. 
| Item | Represents a purchasable resource. 
| Polypoints | A virtual money responsible of the gamification of Polycode. Polypoints can be used to buy items. The user and team leader boards are based on the number of Polypoints. Polypoints can be earned by completing contents or modules. 
| Runner | A service that executes code in a given language and returns the output (stdout and stderr). 
| Submittable | A component that can be submitted for validation by a user to the application. 
| Submission | A user's answer to a submittable. Can be validated through a validator.
| Team | Group of users. One of them is the team's captain. The team's Polypoint count is the sum of the Polypoints of its users. Team are ranked according to their Polypoints. 
| Validator | Validate users submission. 
| Tag | Keyword associated to a resource used for statistics and filtering.
| Purchase | Items that was bought by a user.
|===

== User stories
Now that we agree on the vocabulary, and that we clearly defined what are the meaning behind words in the scope of the Polycode application, we now need to define the features that needs to be available to all our users. This can be done using user stories. They define actions that someone should be able to do on the platform, giving context as why they want to do so. Defining why they want to do so tries to make sure we define features that makes sense, and to keep the end goal in sight.

Here are the user stories we came up with, based on our client specifications:

|===
| As a | I want to | In order to
| Guest | Create my account | Use the application functionalities
| User | Update my email | Recover my account if I was to change my email address
| User | Reset my password using my email | Recover my account if I was to forget my password
| User | Receive a welcome mail when I sign up | Be notified when my registration is completed
| User | Show my account details | To review my personal information
| User | Show other's details | To gather information about another user
| User | Change my username, my preferred programming language and my bio | Update personal information and settings if there was to change
| User | Delete my account | Delete my fingerprint on the Polycode application
| User | Connect to my account using my username and my password | Access the application's functionalities
| User | Logout of my account | Avoid non authorized access from a computer I used
| User | Create a new team | Gather a user group and participate to teams leader board
| Captain | Invite other users in my team | Grow my team
| Captain | Delete a member from my team | Remove a problematic member, for whatever reasons
| Captain | Give the captain role to another member of my team | Dispose of my role
| Captain | Delete my team | Delete this team's fingerprint on Polycode, for whatever reasons
| Captain | Change the name and the description of my team | Keeping the team's infos up to date
| User | Accept or decline a team invite | Join the team I want to join
| User | Leave a team | Not being associated to a certain group of user
| User | See my team's points | Follow my team progress
| User | See the teams leader board | See my team placement
| User | See the internal ranking of my team's members | See who participates the most in the team
| User | See the list of available exercises | Choose an exercise
| User | See the list of available modules | Choose a module
| User | See the sub-modules and exercises of a module | See the steps needed to complete the module
| User | See the list of available evaluations | Choose an evaluation to pass
| User | See the latest exercises / modules posted online | See the new content
| User | See the information of an exercise | Get information on the subject of an exercise
| User | See the information of a module | Get information on the subject of the module, the objective
| User | See the information of an evaluation | Get information on the subject of the evaluation, the objective
| User | See the statement of an exercise | Know the problem to be solved and the questions to answer before validating the concept
| User | Propose a solution to the exercise | Earn PolyPoints and progress in the associated module
| User | In the case of code to be written, execute an intermediate validator | Check if my code is correct for the validator in question
| User | Save the last solution that was the most successful | Take the code from a different device, at another time, to improve it
| User | Write (and modify) my code solution in an editor integrated into the exercise page (code exercise case) | Propose a solution to the exercise
| User | Add files to the editor | Organize my solution into multiple files
| User | Delete files in the editor | Organize the solution into multiple files
| User | Buy hints with PolyPoints | Better understand how to solve the exercise
| User | Follow my progress in each module | See what I completed, and what's still in progress
| User | See the global leader board users | Gain motivation to reach the top
| User | Take an evaluation | Get a certification
| User | Read the content of a course | Become competent on a subject
| Content Creator | Create an exercise, add markdown, a code editor, a QCM | Teach a new concept, check the knowledge of this concept with a question / code to be written
| Content Creator | Create a module | Organize exercises by major concept / theme
| Assessment Creator | Create an test | check the skill set of a user on something
| Content Creator | Add my exercises to a module I have created | Fill the content of a module with a coherent and organized set of elements
| Content Creator | Add submodules to a module | Fill the content of a module with a coherent and organized set of elements

| Content Creator | Delete a content I created | Fix a mistake or delete the existence of this content
| Content Creator | Delete a module I created | Fix a mistake or delete the existence of this module
| Assessment Creator | Delete a test I created | Fix a mistake or delete the existence of this test
| Assessment Creator | See the results of my test | Mark a candidate
| Admin | Promote a user to a creator | Add a new creator
| Admin | Promote a user to an admin | Add a new admin
| Admin | Fetch data of a user | See the personal information of a user
| Admin | Update user's data | Help recover and fix problems with a user account
| Admin | Delete a user | Remove access of a user
| Admin | Have a content creator or assessment creator permissions | Edit and manage existing content, if the need arise
| Admin | Have a user permissions | Use the site as a normal user
| Assessment Creator | Create a campaign | Test a set of candidates
| Assessment Creator | Add candidates via a web interface | Add candidates to my campaign
| Assessment Creator | Delete candidates via a web interface | Delete candidates to my campaign
| Assessment Creator | Add candidates via a web API | Add candidates to my campaign
| Assessment Creator | Delete candidates via a web API | Delete candidates to my campaign
| Assessment Creator | Add candidates via a CSV file | Add candidates to my campaign
| Assessment Creator | See results and stats of a campaign I created | Evaluate the candidates level
| Assessment Creator | Add tags to candidates | Group candidates
| Assessment Creator | Define a expiration time for my campaign | Close my campaign at a fixed time
| Candidate | Come back to a test, without losing my progress | Finish my test if I were to leave the app
| Assessment Creator | Define a limited time for each of my questions | Restrain the maximum time a candidate has for a question
| Assessment Creator | Define the points a question can give | Score candidates
| Candidate | Receive a mail to opt-in the campaign | Join or decline a campaign
| Candidate | Accept a campaign | Participate in a campaign
| Candidate | Decline a campaign | Not participate in a campaign, and notify the creator
| Assessment Creator | Edit my campaign | Fix mistakes or edit its content
| Assessment Creator | Define a beginning date for my campaign | Time frame my campaign
| Assessment creator | Manually send begin campaign mail to candidates | Customize the campaign access
| Candidate | Receive a email when I finished passing my test | Get a confirmation that my answers was taken into account
| Assessment Creator | Visualize the results by tag in a graph | Better visualize results
| Assessment Creator | Export summed up results as PDF | Save results in a synthetic way
| Assessment Creator | Export detailed results as PDS | Save results and have them available locally
| Assessment Creator | Compare candidates results via a excel document | Compare candidates
| Assessment Creator | Sort candidates by tags or results | Compare candidates using the criteria I want
|===

== Domain Driven Design (DDD) ==
Great! We now have defined a common language around the Polycode domain, and we also have explicitly defined the features and expected user interaction with our app. We now have a solid foundation to start thinking about the architecture of our application. In order to make this goal more achievable, and to actually come up with a sensible approach, we are going to design our architecture based on the functional needs of our applications. Starting high up in the mental model of relations between components of our application, diving deeper and deeper until we come up with an actual microservice architecture. This is called Domain Driven Design.

I will introduce the vocabulary linked to DDD when needed. Here's the important ones that you should now before going any further with DDD: 

* Domain: The sphere of knowledge or activity related to a particular subject or business. In the context of software development, the domain is the area of expertise or focus of the system being developed.
* Domain model: A representation of the key concepts, relationships, and rules within a domain. A domain model is used to capture and communicate the understanding of the domain to both domain experts and developers.

=== The origin ===
Domain-driven design (DDD) is a software development approach that focuses on the design and development of a system from the perspective of the business domain it operates in. It was first proposed by Eric Evans in his book __Domain-Driven Design: Tackling Complexity in the Heart of Software__ which was published in 2003. DDD is based on the idea that by better understanding the business domain and the underlying processes, it is possible to design and develop more effective software systems that can help organizations operate more efficiently and effectively. In his book, Eric Evans defines key component around this approach, as well as identifying and naming common patterns you often encounter in complex, business-logic-heavy domains. This book triggered several engineers and practitioners in this field, to add onto this idea.
As you might have realized, the origin of DDD is not rooted within the microservice world. It is a software design approach that can be applied more broadly, when developing software, although it suits particularly well our microservice architecture.

=== What is the goal ===
Why should we design our application this way ? Why not just dive right into developing microservices, creating new one every time it __feels__ like the right choice ?

Your intuition might be right, but several problems arise :

* Getting it right gets exponentially more difficult the more complex your domain is. Moreover, xref:costOfMicroservices[as mentioned in the introduction], if you have a simple architecture, microservice might not be the best fit for you.
* Even if you're right, you need to justify your choices. Intuition is not a justification.
* You need to document your architecture, and the steps you've taken to get to here. This is important for anyone joining your team, to truly understand the decisions that have been made, why the current state of this architecture is the way it is.
* If you're wrong, it's much more difficult to come back and rethink your design. You will have no base to work with. This won't be a revision of what you've made, it's starting from the ground up once again.

And if it looks to costly to fix your architecture or if you're too stubborn to realize that you've made a mistake, you will have to work around those errors, adding band-aid on top of band-aids, and you'll have a unreliable, under-performing, hard to maintain architecture. It is key to understand that the decisions you're making when designing your architecture will impact every line of code written.

The goal of domain-driven design (DDD) is to help developers create software that accurately reflects the business domain and can be easily understood and maintained by domain experts. By aligning the software with the needs and goals of the business, DDD helps ensuring that the software is able to effectively support the business and its operations.

=== Microsoft ===
I wanted to highlight the work done by the Microsoft engineers in documenting and creating a microservice architecture. Their architecture documentation is a great resource, and I've learnt most of what I'm applying through it. As a matter of fact, I will apply their process for creating a microservice application using a DDD approach. I **highly** suggest reading their documentation https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/[here] and https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis[here] for a better understanding of DDD. We will walk trough each step in this chapter, but having a deeper understanding that the very high level overview that I'm going to give through this paper is worth it. Note that, while going much deeper, the Microsoft documentation is not the bible of DDD, and you might want to read https://www.amazon.fr/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215[__Domain-Driven Design: Tackling Complexity in the Heart of Software__] instead.
Microsoft goes much more into details about where using DDD to define your architecture makes sense. There is a lot to say about DDD, and this is misaligned with the core goal of this chapter, which is to explain the thought-process I had when architecting Polycode.

== Polycode Domain ==
Domain Driven Design starts high up, with domain experts, and progressively dive in deeper until we have a clear architecture. But what are domain experts ? What is our domain exactly ? Let's start with the basics.
Domain experts are the people that are knowledgeable in their field, and provide the necessary expertise to ensure that the software accurately reflects the real-world domain it is intended to model. But what is our domain ? Good thing for us is that we already did all the hard-work. We defined our ubiquitous language around Polycode, and our user-stories to define the functionalities. Talking with domain experts, we can plot all our vocabulary on a diagram to better understand all the parts around Polycode. Here's what I came up with:

image:10_Domains/TAD_10_PolycodeDomain.png[]

This diagram gives an overview of relations between concepts inside our Polycode domain. This is already quite a lot to work with ! It might look frightening at first, manufacturing a great architecture out of these seemingly abstract vocabulary might be concerning. Don't be, DDD will guide us.

== Bounded Contexts ==
If you've read the Microsoft documentation or if you've had some experience with DDD, you'll know the next step is to define bounded contexts.
A bounded context is a specific way of defining the boundaries and scope of a domain. It is a way of partitioning the domain into smaller, more manageable pieces that can be developed and understood independently, but still fit within the overall context of the domain. The goal of a bounded context is to create a clear separation between different parts of the domain and to explicitly define the ways in which they interact with one another. 
We are going to divide our Polycode domain in a subset of contexts, that can be worked on independently. I'll give my take on the Polycode bounded contexts, and explain why each of them makes sense:

image:10_Domains/TAD_10_BoundedContexts.png[]

As you can see, I've divided the domain in 4 bounded contexts:

* The user context, which I also might refer as the account context, is the context where we have a deep knowledge about what a user is. This is where we handle his settings, account management, authentication. This is also the context responsible of sending emails, since an email is intrinsically linked to users.
* The practice context is responsible of handling the practice side of Polycode. This is where we have knowledge about teams and items, where we handle user progression and defines modules that the user will be able to follow. It is important to note that the notion of user in the practice context is not the same as the notion of user in the user context. A user, in the practice context, does not have a password or even an email. It is not needed in this context. This means that there will be translation layer in the communication between contexts, and this is normal. This is the cost we have to pay to make each of our context easy to work with and self-contained.
* The assessment context, in the same regards that the practice context, is responsible of handling the assessment side of Polycode. Separating it from the practice context makes sense to me, since we are handling a very different business logic. We need to grade candidates, with an invitation system on test that have a limit in time and that you can't retry.
* The content context. This is the harder one to justify, and it might look like I've let the technical implementation and details take over my thought process. I don't think this is the case. Wether you are in the practice or assessment context, you're not really concerned about the content itself, but more about the functionalities around it. You're concerned about what is a module, and that it has content within it, but whatever is the content. What is important to you is "Did the user finish this content ?" for example. In the content context, we don't really care where the content actually is. What we care about is inside this content, can we validate it, can we execute it ? How can we create new contents ? Contents exists in the assessment (as a question) and practice context, but they have a very different purpose than in the content context.

The great thing with DDD, is that it can be an iterative process. If you realize that you've made a mistake, you can always come back to the previous step and fix it. And since we're dividing our domain into contexts very early, if we were to come to make a mistake, it should not impact the other bounded contexts.

Now that we have defined our bounded contexts, let's move on to the next step.

== Tactical DDD ==
We have defined our bounded contexts, and successfully divided Polycode into smaller, workable domains. This is great, from now on we can move in parallel, with domain experts for each of our bounded contexts identifying the key elements within each of our contexts. But our bounded contexts is still way too broad, we still can't jump to microservices directly.
We need to define our domain model with more precision. To do so, we will be using tactical DDD.

The first step is to identify and categorize all the area of functionalities you have. Tactical DDD defines the following categories : 

* Entity: A domain object that is defined by its identity and attributes, rather than its behavior. Entities are typically used to represent things or concepts in the domain that have a long-lived existence and are subject to change over time.
* Value object: A domain object that is defined by its attributes, rather than its identity. Value objects are typically used to represent things or concepts in the domain that are immutable and do not have a long-lived existence.
* Aggregate: A group of related domain objects that are treated as a single unit. An aggregate is used to enforce consistency and to ensure that certain invariants are maintained within the system.
* Service: A domain object that is defined by its behavior and is not tied to a specific entity or value object. Services are used to encapsulate business logic that is not closely related to a particular domain object.
* Domain events: A domain object that conveys information when something happens in the domain. This is useful to synchronize microservice, since they usually don't share data stores.

Once again, for a more detailed description of each of them, a highly recommend reading the https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd[Microsoft's documentation].

With the terminology set, we now need to analyze each of our bounded contexts, and come up with a well-defined and precise domain model.

=== The user context ===
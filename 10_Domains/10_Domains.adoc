= From domains to microservices =

== Introduction ==
It's important to recognize the way you design you microservices will be reflected on the quality of your application. Poorly divided microservices will result in poor performance, poor maintainability, poor developer experience, and overall a bad user experience. If your data is poorly isolated, it will span multiple microservices and create a integrity and consistency mess. Make microservices too big and you lose the benefits. Make microservices too small and you begin to overload your network infrastructure, increase costs, decrease maintainability and increase your risks of bugs. Whatever your implementation, a poorly designed infrastructure will cause headaches. Let's see how we can create a sensible microservice architecture, using Polycode as our use case.

The first step in decomposing your application into microservices is to understand the domain that it lives in. To make sure that everybody is on the same page, and to provide a common vocabulary for your engineers, marketing team, executive team, architects and whoever might be working on the project, we need to define the language that is used around your project.

== Ubiquitous Language ==
The ubiquitous language is a common vocabulary everybody involved in the project should define together and use to communicate. The goal is to make sure that everybody refers to the same concept when talking about the project, reducing confusion and misunderstanding, avoiding conflicts and unnecessary discussion.

As the Polycode team, we defined the following vocabulary for the Polycode project. Please take some time to read through it, to make sure your understanding is aligned with mine.


|===
| Word | Definition 
| Practice | A section of Polycode made to train users 
| Assessment | A section of Polycode made to evaluate user 
| Admin | A privileged user that have access and permission to manage all resources in Polycode. 
| User | Someone who has a Polycode account. 
| Candidate | A person who participate to a test or assessment. 
| Guest | Someone who doesn't have an account. 
| Captain | A user who manages a team. 
| Assessment Creator | A user who can edit or create assessment, and invite candidates. 
| Practice Creator / Content creator | A user who can edit or create his content. 
| Test | It is an ordered group of contents made to evaluate users. It has a grade, which is the total score divided by the total number of points in the set of contents. It is created by an assessment creator. 
| Campaign | Usage of a test on a group of candidates 
| Module | A grouping, possibly nested, holding contents and that can give points when fully completed. 
| Content | A content is a coherent group of components. The contents are organized in a tree structure. The modules are branches and the contents are leaves. In other words, unlike modules, a content can't contain modules or other contents. 
| Component | Its a small unit of what will be displayed to the end users. You must use components to build your content, components compose contents. Can be of multiple types, a markdown or an editor for example. 
| Hint | A hint is an item to help the user to finish a component in exchange for PolyPoints. 
| Item | Represents a purchasable resource. 
| Polypoints | A virtual money responsible of the gamification of Polycode. Polypoints can be used to buy items. The user and team leader boards are based on the number of Polypoints. Polypoints can be earned by completing contents or modules. 
| Runner | A service that executes code in a given language and returns the output (stdout and stderr). 
| Submittable | A component that can be submitted for validation by a user to the application. 
| Submission | A user's answer to a submittable. Can be validated through a validator.
| Team | Group of users. One of them is the team's captain. The team's Polypoint count is the sum of the Polypoints of its users. Team are ranked according to their Polypoints. 
| Validator | Validate users submission. 
| Tag | Keyword associated to a resource used for statistics and filtering.
| Purchase | Items that was bought by a user.
|===

== User stories
Now that we agree on the vocabulary, and that we clearly defined what are the meaning behind words in the scope of the Polycode application, we now need to define the features that needs to be available to all our users. This can be done using user stories. They define actions that someone should be able to do on the platform, giving context as why they want to do so. Defining why they want to do so tries to make sure we define features that makes sense, and to keep the end goal in sight.

Here are the user stories we came up with, based on our client specifications:

|===
| As a | I want to | In order to
| Guest | Create my account | Use the application functionalities
| User | Update my email | Recover my account if I was to change my email address
| User | Reset my password using my email | Recover my account if I was to forget my password
| User | Receive a welcome mail when I sign up | Be notified when my registration is completed
| User | Show my account details | To review my personal information
| User | Show other's details | To gather information about another user
| User | Change my username, my preferred programming language and my bio | Update personal information and settings if there was to change
| User | Delete my account | Delete my fingerprint on the Polycode application
| User | Connect to my account using my username and my password | Access the application's functionalities
| User | Logout of my account | Avoid non authorized access from a computer I used
| User | Create a new team | Gather a user group and participate to teams leader board
| Captain | Invite other users in my team | Grow my team
| Captain | Delete a member from my team | Remove a problematic member, for whatever reasons
| Captain | Give the captain role to another member of my team | Dispose of my role
| Captain | Delete my team | Delete this team's fingerprint on Polycode, for whatever reasons
| Captain | Change the name and the description of my team | Keeping the team's infos up to date
| User | Accept or decline a team invite | Join the team I want to join
| User | Leave a team | Not being associated to a certain group of user
| User | See my team's points | Follow my team progress
| User | See the teams leader board | See my team placement
| User | See the internal ranking of my team's members | See who participates the most in the team
| User | See the list of available exercises | Choose an exercise
| User | See the list of available modules | Choose a module
| User | See the sub-modules and exercises of a module | See the steps needed to complete the module
| User | See the list of available evaluations | Choose an evaluation to pass
| User | See the latest exercises / modules posted online | See the new content
| User | See the information of an exercise | Get information on the subject of an exercise
| User | See the information of a module | Get information on the subject of the module, the objective
| User | See the information of an evaluation | Get information on the subject of the evaluation, the objective
| User | See the statement of an exercise | Know the problem to be solved and the questions to answer before validating the concept
| User | Propose a solution to the exercise | Earn PolyPoints and progress in the associated module
| User | In the case of code to be written, execute an intermediate validator | Check if my code is correct for the validator in question
| User | Save the last solution that was the most successful | Take the code from a different device, at another time, to improve it
| User | Write (and modify) my code solution in an editor integrated into the exercise page (code exercise case) | Propose a solution to the exercise
| User | Add files to the editor | Organize my solution into multiple files
| User | Delete files in the editor | Organize the solution into multiple files
| User | Buy hints with PolyPoints | Better understand how to solve the exercise
| User | Follow my progress in each module | See what I completed, and what's still in progress
| User | See the global leader board users | Gain motivation to reach the top
| User | Take an evaluation | Get a certification
| User | Read the content of a course | Become competent on a subject
| Content Creator | Create an exercise, add markdown, a code editor, a QCM | Teach a new concept, check the knowledge of this concept with a question / code to be written
| Content Creator | Create a module | Organize exercises by major concept / theme
| Assessment Creator | Create an test | check the skill set of a user on something
| Content Creator | Add my exercises to a module I have created | Fill the content of a module with a coherent and organized set of elements
| Content Creator | Add submodules to a module | Fill the content of a module with a coherent and organized set of elements

| Content Creator | Delete a content I created | Fix a mistake or delete the existence of this content
| Content Creator | Delete a module I created | Fix a mistake or delete the existence of this module
| Assessment Creator | Delete a test I created | Fix a mistake or delete the existence of this test
| Assessment Creator | See the results of my test | Mark a candidate
| Admin | Promote a user to a creator | Add a new creator
| Admin | Promote a user to an admin | Add a new admin
| Admin | Fetch data of a user | See the personal information of a user
| Admin | Update user's data | Help recover and fix problems with a user account
| Admin | Delete a user | Remove access of a user
| Admin | Have a content creator or assessment creator permissions | Edit and manage existing content, if the need arise
| Admin | Have a user permissions | Use the site as a normal user
| Assessment Creator | Create a campaign | Test a set of candidates
| Assessment Creator | Add candidates via a web interface | Add candidates to my campaign
| Assessment Creator | Delete candidates via a web interface | Delete candidates to my campaign
| Assessment Creator | Add candidates via a web API | Add candidates to my campaign
| Assessment Creator | Delete candidates via a web API | Delete candidates to my campaign
| Assessment Creator | Add candidates via a CSV file | Add candidates to my campaign
| Assessment Creator | See results and stats of a campaign I created | Evaluate the candidates level
| Assessment Creator | Add tags to candidates | Group candidates
| Assessment Creator | Define a expiration time for my campaign | Close my campaign at a fixed time
| Candidate | Come back to a test, without losing my progress | Finish my test if I were to leave the app
| Assessment Creator | Define a limited time for each of my questions | Restrain the maximum time a candidate has for a question
| Assessment Creator | Define the points a question can give | Score candidates
| Candidate | Receive a mail to opt-in the campaign | Join or decline a campaign
| Candidate | Accept a campaign | Participate in a campaign
| Candidate | Decline a campaign | Not participate in a campaign, and notify the creator
| Assessment Creator | Edit my campaign | Fix mistakes or edit its content
| Assessment Creator | Define a beginning date for my campaign | Time frame my campaign
| Assessment creator | Manually send begin campaign mail to candidates | Customize the campaign access
| Candidate | Receive a email when I finished passing my test | Get a confirmation that my answers was taken into account
| Assessment Creator | Visualize the results by tag in a graph | Better visualize results
| Assessment Creator | Export summed up results as PDF | Save results in a synthetic way
| Assessment Creator | Export detailed results as PDS | Save results and have them available locally
| Assessment Creator | Compare candidates results via a excel document | Compare candidates
| Assessment Creator | Sort candidates by tags or results | Compare candidates using the criteria I want
|===

== Domain Driven Design (DDD) ==
Great! We now have defined a common language around the Polycode domain, and we also have explicitly defined the features and expected user interaction with our app. We now have a solid foundation to start thinking about the architecture of our application. In order to make this goal more achievable, and to actually come up with a sensible approach, we are going to design our architecture based on the functional needs of our applications. Starting high up in the mental model of relations between components of our application, diving deeper and deeper until we come up with an actual microservice architecture. This is called Domain Driven Design.

I will introduce the vocabulary linked to DDD when needed. Here's the important ones that you should now before going any further with DDD: 

* Domain: The sphere of knowledge or activity related to a particular subject or business. In the context of software development, the domain is the area of expertise or focus of the system being developed.
* Domain model: A representation of the key concepts, relationships, and rules within a domain. A domain model is used to capture and communicate the understanding of the domain to both domain experts and developers.

=== The origin ===
Domain-driven design (DDD) is a software development approach that focuses on the design and development of a system from the perspective of the business domain it operates in. It was first proposed by Eric Evans in his book __Domain-Driven Design: Tackling Complexity in the Heart of Software__ which was published in 2003. DDD is based on the idea that by better understanding the business domain and the underlying processes, it is possible to design and develop more effective software systems that can help organizations operate more efficiently and effectively. In his book, Eric Evans defines key component around this approach, as well as identifying and naming common patterns you often encounter in complex, business-logic-heavy domains. This book triggered several engineers and practitioners in this field, to add onto this idea.
As you might have realized, the origin of DDD is not rooted within the microservice world. It is a software design approach that can be applied more broadly, when developing software, although it suits particularly well our microservice architecture.

=== What is the goal ===
Why should we design our application this way ? Why not just dive right into developing microservices, creating new one every time it __feels__ like the right choice ?

Your intuition might be right, but several problems arise :

* Getting it right gets exponentially more difficult the more complex your domain is. Moreover, xref:costOfMicroservices[as mentioned in the introduction], if you have a simple architecture, microservice might not be the best fit for you.
* Even if you're right, you need to justify your choices. Intuition is not a justification.
* You need to document your architecture, and the steps you've taken to get to here. This is important for anyone joining your team, to truly understand the decisions that have been made, why the current state of this architecture is the way it is.
* If you're wrong, it's much more difficult to come back and rethink your design. You will have no base to work with. This won't be a revision of what you've made, it's starting from the ground up once again.

And if it looks to costly to fix your architecture or if you're too stubborn to realize that you've made a mistake, you will have to work around those errors, adding band-aid on top of band-aids, and you'll have a unreliable, under-performing, hard to maintain architecture. It is key to understand that the decisions you're making when designing your architecture will impact every line of code written.

The goal of domain-driven design (DDD) is to help developers create software that accurately reflects the business domain and can be easily understood and maintained by domain experts. By aligning the software with the needs and goals of the business, DDD helps ensuring that the software is able to effectively support the business and its operations.

=== Microsoft ===
I wanted to highlight the work done by the Microsoft engineers in documenting and creating a microservice architecture. Their architecture documentation is a great resource, and I've learnt most of what I'm applying through it. As a matter of fact, I will apply their process for creating a microservice application using a DDD approach. I **highly** suggest reading their documentation https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/[here] and https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis[here] for a better understanding of DDD. We will walk trough each step in this chapter, but having a deeper understanding that the very high level overview that I'm going to give through this paper is worth it. Note that, while going much deeper, the Microsoft documentation is not the bible of DDD, and you might want to read https://www.amazon.fr/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215[__Domain-Driven Design: Tackling Complexity in the Heart of Software__] instead.
Microsoft goes much more into details about where using DDD to define your architecture makes sense. There is a lot to say about DDD, and this is misaligned with the core goal of this chapter, which is to explain the thought-process I had when architecting Polycode.

== Polycode Domain ==
Domain Driven Design starts high up, with domain experts, and progressively dive in deeper until we have a clear architecture. But what are domain experts ? What is our domain exactly ? Let's start with the basics.
Domain experts are the people that are knowledgeable in their field, and provide the necessary expertise to ensure that the software accurately reflects the real-world domain it is intended to model. But what is our domain ? Good thing for us is that we already did all the hard-work. We defined our ubiquitous language around Polycode, and our user-stories to define the functionalities. Talking with domain experts, we can plot all our vocabulary on a diagram to better understand all the parts around Polycode. Here's what I came up with:

.Polycode domains
image:10_Domains/TAD_10_PolycodeDomain.png[]

This diagram gives an overview of relations between concepts inside our Polycode domain. This is already quite a lot to work with ! It might look frightening at first, manufacturing a great architecture out of these seemingly abstract vocabulary might be concerning. Don't be, DDD will guide us.

== Bounded Contexts ==
If you've read the Microsoft documentation or if you've had some experience with DDD, you'll know the next step is to define bounded contexts.
A bounded context is a specific way of defining the boundaries and scope of a domain. It is a way of partitioning the domain into smaller, more manageable pieces that can be developed and understood independently, but still fit within the overall context of the domain. The goal of a bounded context is to create a clear separation between different parts of the domain and to explicitly define the ways in which they interact with one another. 
We are going to divide our Polycode domain in a subset of contexts, that can be worked on independently. I'll give my take on the Polycode bounded contexts, and explain why each of them makes sense:

.Polycode bounded contexts
image:10_Domains/TAD_10_BoundedContexts.png[]

As you can see, I've divided the domain in 4 bounded contexts:

* The user context, which I also might refer as the account context, is the context where we have a deep knowledge about what a user is. This is where we handle his settings, account management, authentication. This is also the context responsible of sending emails, since an email is intrinsically linked to users.
* The practice context is responsible of handling the practice side of Polycode. This is where we have knowledge about teams and items, where we handle user progression and defines modules that the user will be able to follow. It is important to note that the notion of user in the practice context is not the same as the notion of user in the user context. A user, in the practice context, does not have a password or even an email. It is not needed in this context. This means that there will be translation layer in the communication between contexts, and this is normal. This is the cost we have to pay to make each of our context easy to work with and self-contained.
* The assessment context, in the same regards that the practice context, is responsible of handling the assessment side of Polycode. Separating it from the practice context makes sense to me, since we are handling a very different business logic. We need to grade candidates, with an invitation system on test that have a limit in time and that you can't retry.
* The content context. This is the harder one to justify, and it might look like I've let the technical implementation and details take over my thought process. I don't think this is the case. Wether you are in the practice or assessment context, you're not really concerned about the content itself, but more about the functionalities around it. You're concerned about what is a module, and that it has content within it, but whatever is the content. What is important to you is "Did the user finish this content ?" for example. In the content context, we don't really care where the content actually is. What we care about is inside this content, can we validate it, can we execute it ? How can we create new contents ? Contents exists in the assessment (as a question) and practice context, but they have a very different purpose than in the content context.

The great thing with DDD, is that it can be an iterative process. If you realize that you've made a mistake, you can always come back to the previous step and fix it. And since we're dividing our domain into contexts very early, if we were to come to make a mistake, it should not impact the other bounded contexts.

Now that we have defined our bounded contexts, let's move on to the next step.

== Tactical DDD ==
We have defined our bounded contexts, and successfully divided Polycode into smaller, workable domains. This is great, from now on we can move in parallel, with domain experts for each of our bounded contexts identifying the key elements within each of our contexts. But our bounded contexts is still way too broad, we still can't jump to microservices directly.
We need to define our domain model with more precision. To do so, we will be using tactical DDD.

The first step is to identify and categorize all the area of functionalities you have. Tactical DDD defines the following categories : 

* Entity: A domain object that is defined by its identity and attributes, rather than its behavior. Entities are typically used to represent things or concepts in the domain that have a long-lived existence and are subject to change over time.
* Value object: A domain object that is defined by its attributes, rather than its identity. Value objects are typically used to represent things or concepts in the domain that are immutable and do not have a long-lived existence.
* Aggregate: A group of related domain objects that are treated as a single unit. An aggregate is used to enforce consistency and to ensure that certain invariants are maintained within the system.
* Domain Service: A domain object that is defined by its behavior and is not tied to a specific entity or value object. Services are used to encapsulate business logic that is not closely related to a particular domain object.
* Domain events: A domain object that conveys information when something happens in the domain. This is useful to synchronize microservice, since they usually don't share data stores.
* Application Service: A object that is needed for the domain to work, but is not directly related to the domain. This is a SMS Message service for 2 Factor authentication for example.

Once again, for a more detailed description of each of them, a highly recommend reading the https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd[Microsoft's documentation].

With the terminology set, we now need to analyze each of our bounded contexts, and come up with a well-defined and precise domain model.

=== The user context ===
Using the terminology above, I've divided the user bounded context and identified the following entities:

.Account entities
image::10_Domains/TAD_10_Account_DDD.png[]

This is a pretty simple context, not much to define here. Let's go over what I came up with.

As entities, we have the User entity and the Email entity. The user defines the basics of what is a user, in the account bounded context. A user should have a name, an email, and a unique identifier. We don't need to define anything else in this bounded context.

I've also defined a Email entity. This entity is here to represent and store emails sent to users (validation emails for example). It is important to note that there is a reference to its corresponding user, via a userId. I'm also storing the destination email. By doing so, we make sure that we know the destination email at the time the email was sent. A user might change its email, and if we rely on the User entity, we lose this information.

The User is also an aggregate, composed of the user entity as the root, and the email entity as children of user. We want consistency between our user and email, especially in this context, since we are dealing with user data. We want to make sure that when deleting a user, all its related sent email are also deleted. This is important to respect user data privacy, and to comply with GRPD.

I've defined the Email Status value object, which represents the status of an email. The email status of an email should only be modified via the aggregate. 

There is a need for an application service. We want to send mail, so we need a service that can actually send mail. This is not tied to the business logic itself, and is here to provide technical functionality.

Finally, I've also defined the Email Status domain event, which will notify the domain whenever a email changes status. This event should be sent when a email is created, when it has successfully been sent, or when it failed.

=== The practice context ===
Let's take a look at my take on the domain model for the practice bounded context:

Entities and value objects:

.Practice entities and values objects
image::10_Domains/TAD_10_Practice_Entities_VOs_DDD.png[]

Aggregates:

.Practice aggregates
image::10_Domains/TAD_10_Practice_Aggregates_DDD.png[]

As you can see, I've defined the User entity, which is a different entity than the one in the Account context. However, the field `accountId` makes the link between the two. There is additional information that is relevant only within the practice context, and that's why there is a separate entity in it.
User is also an aggregate, composed of the User as the root entity. It is linked to UserProgression, Team and Purchase, since I have identified a need for transactional consistency. In the case of Purchase, there is a need for consistency when the user buys an item. We need to make sure that he has enough polypoints, and the transaction should fail if there is an error in either updating its polypoints, or an error when registering the Purchase.
There is a similar need for the user progression. Registering user progress and adding the corresponding rewards to its polypoints should be done in one transaction.

This is a great example of what aggregates are for. You don't want to be able to update Purchase without having the correlated side-effects. This is usually taken care of your database in a monolith application, where everything is done within one transaction. However, in a microservice architecture, it's the job of the application layer to have this responsibility.

This is the same case for a Team. When updating or adding a new User to a team, we have consistency to be checked. The user must not be part of another Team for example. And when deleting a user, we have to make sure to stay consistent in the related entities, such as the Team the user might have been a part of. If the user was the captain, we need to elect a new captain for the team.

However, this kind of consistency check is not needed when we are not mutating the data. This is where patterns like CQRS shines, and allows for a better segmentation of your data access, and allow a much needed optimization in the case where your requirements for the command model and the query model are significantly different. We are not allowed to use CQRS in this paper, so I will not dive further into it.

I've defined Item as an entity, which is also an aggregate with only itself as a child. This means, however, that there is no guaranteed consistency when updating or deleting an item and its reference in the Purchase entity. If an item is deleted, purchases will have ghost references. But, as a domain expert, I would argue that an Item can never be deleted. Once you've proposed to your users an item, this item is here to stay. Its price can be updated, it can be purchasable or not, but once it is out, there is no going back. This constraint will need to be respected, because the User aggregate, and more specifically the Purchase entity, will make the assumption that an Item is never deleted.

I would now like to bring your focus to the Content entity. As we will discuss later, a Content is a totally different thing in the content context (content means a lot of different thing here, I'll try to make it clear). But in the practice context, we don't care about what is a content in a content context. We just now that OUR content has a name, description and a reward.
An important realization to have, is that the content entities in the two contexts will not even be tied 1 to 1. Indeed, a content in the practice context is unique for each module. This allows us to re-use contents from the content context, while being able to have different names and description, with different rewards, depending on how it is used in the module.
This makes the content tightly linked with its parent module, this is why I've defined the module aggregate, with the module entity as the root and the contents as child entities. We need to maintain consistency here, when a module is updated or deleted, we need to make sure to propagate the needed actions to the contents.

You might also have noticed that there is a link between content and modules, and the user progression. They are, however, not in the same aggregate. It's OK if we don't have consistency here, the main purpose of the user progression is to store how he got his polypoints. Ideally, we do not delete any content or module, and just set the unused or outdated modules as not available for the end user to see.

I've decided that tags should be an entity on its own, and not a value object. At first glance, it looks like a value object, it has no identity and is valuable only thanks to the value it owns. But in reality, tags will be used to categorize modules and to apply filters. This means that tags should be unique, and by extension identifiable, else we will have cohesion problems and redundancy in our databases. This is more of a technical decisions, but it is emanating from functional realities.

=== The assessment context ===
I've identified the following entities, services, value objects and aggregates for the assessment context:

Entities, value objects and domain services:

.Assessment entities
image::10_Domains/TAD_10_Assessment_Entities_DomainServices_DDD.png[]

There is quite a lot to unpack here. Let's take it step by step, beginning with entities.
We have two types of users in our assessment context: assessors and candidates. Both are tied to a campaign, meaning that a candidate is not a candidate anymore if the campaign doesn't exist. Same thing with an assessor. This is quite logical, you're not an employee if your company doesn't exist anymore, this is the same logic. This also means there is a different dynamic of dependencies and transactional boundaries than in the practice context. This is a hint meaning that we probably divided these two bounded contexts in a sensible manner.
Candidates have a status, which is an enumeration of value it can have. This has no identity, this is why CandidateStatus is a value object.
As seen in the user stories, we need to send quite a lot of mails to our candidates. Even if this is a domain functionality, we delegated this part to our account context, which is why you don't see it appearing here. This will be an area of inter-domain communication.

Each campaign has a single test, which is an array of questions with an overall maximum duration. Since each test is tied to only one campaign, this looks like a 1 to 1 relationship, which is commonly simplified by putting the fields of Test inside Campaign. I've decided against it, to better encapsulate behaviors, and to give room for expansion of functionalities in the future of the application.
A question, is a specialized type of content. This works just like the content from the practice context, with the main difference being the fields describing it. We no longer have rewards but points, we have both a name and an internal name, we have a maximum duration, etc..
Just like in the practice context, we don't really care about what actually is inside our content, how it is going to be validated and displayed. We care about the points it gives. However, unlike specified, we don't have a way do have a fine-grained points distribution. We will look at how we can solve this problem in the content context, where the validation is actually done.

We also have a set of tags associated to the campaign. The assessor can manage this tags and set them to candidates and questions. It is important to have them identified, since we want to apply filters on them, and to find them easily. The business flow would look like this:

* Assessor creates or updates a tag
* Assessor adds a question to a test
* Assessor adds the tag previously created to the question
* Assessor updates the tag of a candidate with the previously created tag

We don't want the assessor to manually type in a tag for each of the questions, as it would introduce inconsistency, under-performing queries and most importantly, a bad user experience.

Just like with the content type withing the practice context, we also have a "helper" field to better identify what type of question it is, in the form of the value object QuestionType.
Lastly for the value objects, I've defined Candidate Progression, which holds the current progression of a candidate. It has no identity by itself, and is here to define the current progression of a candidate within the campaign's test.

I have identified one domain service: reports. This service will be responsible for generating the data for each campaign. It might be interesting to create some already computed statistics about a campaign once it is finished, and store it in an entity, but given the most likely low volume of candidates and campaigns, I think it is better for now to just compute the data every time.


Aggregates:

.Assessment aggregates
image::10_Domains/TAD_10_Assessment_Aggregates_DDD.png[]

I've defined only one aggregate, the campaign aggregate. As discuss previously, everything in the assessment bounded context is tied to a campaign, with a need for transactional consistency between all of them. The campaign entity will act like the gateway for all the children entities, making sure to take appropriate actions for each modifications and rolling back failed actions. This is a big aggregate and we will see how to deal with it later on. This is not a problem though, you have to accept that some transactional boundaries spans around a lot in your context. You might want to identify which of your dependencies forces you into this situation, and if there is something to be rethought, but for our assessment context, it's fine, not that big, and I don't think I misidentified links between my entities.

=== The content context ===
Finally, our final context. We have taken a look at all our bounded contexts but one: the content context. Let's dive right into it.

Entities, values objects and domain services:

.Content entities
image::10_Domains/TAD_10_Content_Entities_DomainServices_DDD.png[]

I've defined 4 different entities. Let's start by talking about content.

Content is an entity we found links to both in the practice context (with its own content entity) and in the assessment context (the question entity). However, we've seen a sharp difference between those two already. In this context, content does not mean the same thing as in the previous two contexts. Here, we care about how it works, how it is going to be displayed, and we don't care about the name it or the type it is given in other contexts.

As you can see, a content is actually made of a root component, which itself might be composed of other component, or some text, or an editor. There is always a lot of possibilities, and these possibilities are not fixed in time. This is why we need to have a very flexible way of modeling things, even if we lose in rigidness and gain complexity. This is why most of the entities have fields of value `object`. This means that we don't know the actual data structure it may holds. This can be inferred via the type for example. Or it might be some edge cases where data that is totally unrelated to our context that other context might want to save, if they can't store it in their own context.

This is the same thing with validator. We don't know how exactly we are going to validate each components, it depends of its type and the data structure might evolve over time. We find the same thing with submission. Submission holds a reference to an account, but this is not an entity by itself. A user is just a uuid to somewhere else for us, we have no business with its email or its name. We just need to have a unique identifier for a unique user, so we are going to use the GUID of our users in our systems, the one emanating from the account context. Note that we are not even going to communication with the account context, since in practice, this will be given to us at the moment of a submission.

Having all those objects within our contexts is fine, since all the business logic related to it is kept inside our bounded contexts. Our "external API" should not change, and that's what the other bounded contexts really care about. As discussed previously, they don't need neither want to know how our content will be displayed.

I've defined a domain service: runner. It will be responsible for taking executable code, and running it, returning the results. It does not do any validation, it just executes code. Since this is at the core of the Polycode application, and a topic on its own, I will not dive into details about its implementation and inner-working here.

Let's now look at the aggregates I identified:

.Content aggregates
image::10_Domains/TAD_10_Content_Aggregates_DDD.png[]

I've defined two aggregates:

* The submission aggregate, which has the submission entity at its root. It is linked to a component, but it is not in the same aggregate as components. This is because, as seen before, we don't need consistency here, and we don't even want it. If the component were to be deleted, we want to keep track of all submissions that were linked to it, since users actually submitted something. Deleting a component doesn't delete what the user did. However, this means that we have no guarantee of the existence of the component when parsing submissions, neither do we know if the component was updated since the submission.
* The content aggregate. Here, we need consistency. Indeed, when modifying or deleting a component, we want to update all contents and components accordingly. We don't want to have contents with ghost components, and we must ensure this is not the case. Same things we components and validators. Validators are inherently linked to a component, and we need strong consistency, and check for business logic. An exercise must always have a validator linked to it, but a lesson should not. This consistency needs to be respected.

== Microservices ==
This is the last stretch ! We have now defined a domain model for each of our bounded contexts, and have a clear understanding of where our boundaries are. We now need to translate these more or less abstract concepts into microservices.

=== From domain model to microservices ===
This section is heavily inspired of https://learn.microsoft.com/en-us/azure/architecture/microservices/model/microservice-boundaries?source=recommendations[Microsoft's documentation on the subject].

The last step is to transition from our domain model to our application designs. During this process, don't be afraid to go back and revisit the previous steps, as you might see some problems emerge, that can be caused by a faulty domain model or bounded contexts.

The main criteria your microservices should respect are:

* Each microservice has a single responsibility
* Microservices should not be too chatty
* A microservice should not be too big for a small team
* No hard dependencies on one another. A microservice does not rely on another to be deployed and to work effectively.
* They can evolve independently
* You respect data consistency when there is a need for one

A microservice should not spread over your bounded contexts. If it does, you probably have a problem within your bounded contexts. As you might have realized, some of those criteria are closed to what an aggregate is trying to solve. This means that aggregates are often good starting points as microservices. When in doubt, you should always start with a bigger service, since it is easier to trim it down than to glue up multiple microservices together.

=== Polycode ===
Let's apply the previous criteria to our Polycode application. I will be starting by going over each bounded contexts, and we will talk about inter-contexts communication later.

==== Account microservices ====
Let's discuss how I mapped out my account microservices:

.Account microservices
image::10_Domains/TAD_10_Account_Microservice.png[]

It is very simple and straightforward as you can see, since the domain model is very simple too. There are still some decisions that are not that obvious that were taken:

* The communication between the User service and the Mail service is synchronous, and so is the broadcasting of the EmailStatus Event. This is due to the constraint of not being able to use message queues, but this, to me, would be an obvious fit for a message queue, since we just want our mails to be eventually sent, and this can be done in a totally asynchronous manner.
* I've not divided the email entity within its own service. I think the cost of managing consistency between the two services overwhelms the benefits of splitting it in to microservices. The user microservice still has a single responsibility, which is to manage the users. Emails are part of this responsibility. The microservice is still sufficiently small to be handled by a small team.

As discussed previously, it is better to start with bigger microservices and trim them down later on, rather than refactoring them into one bigger microservice. If the needs arise, we should be able to create a new microservice for handling emails pretty easily.

==== Practice microservices ====
We identified 3 aggregates within our practice microservices: the user aggregate, the module aggregate and the item aggregate. I started by mapping each of them to one microservice, since this is where our transactional boundaries were identified. For the module and item microservices, I've estimated that they are small enough, and that they doesn't need to be divided. However, for our user microservice, which handled the user aggregates, encompassing user progression, teams and purchases entities, I think it is wiser to delegate some of the functionalities to some other microservices.
Indeed, most of those entities are actually quite independent from each other, but also conveys a lot of business logic and intricacies with them.

Let's think about what are the trade-offs we make if we divides each of the sub-entities of the user aggregate in their own domain-driven microservices:

* Purchase entity:
  - Business logic closely related to the user entity, creating a new microservice for it might carry a burden of maintenance and communication across multiple teams.
  - Technically simple (more or less just a CRUD). This makes it hard to justify spinning up a new runtime and new containers for this little of code. This might make more sense if we are edging towards serverless computing, but this is not our case neither within the scope of this paper.
  - Needs very strong consistency with the user entity when updated.
  - Not chatty at all with the user entity. Making a purchase is a rare event. The purchase microservice would not rely on the user microservice for any of its operations. The user microservice would rely on the purchase microservice only when mutating purchases of an user.
* Team entity:
  - Business logic related but not entirely tied to the user entity. 
  - Technically pretty straight-forward, but has a significant amount of business logic to implement, with a growing list of features.
  - Not too chatty with the user entity. Mutating a team is a relatively rare event.
* User-progression entity
  - Business logic closely related to the user entity, creating a new microservice for it might carry a burden of maintenance and communication across multiple teams.
  - Technically simple (more or less just a CRUD)
  - Needs strong consistency. We don't want the user to complete something without crediting the correct number of polypoints to its account.
  - Not too chatty. Only chats when an user finished a content, which is not a rare event by itself, but I would argue it is still not on an order of magnitude high enough to become worrisome.

I didn't choose the purchase entity because I think it's too small and its logic integrates well enough with the user's business logic to go into the same microservice. The same thing goes for the user-progression entity.

However, I think creating a microservice responsible for handling team's business logic makes much more sense: it is quite unrelated from the user entity from a business logic point of view, while not being too chatty. Both of the microservices will grow independently and can be worked on by different teams. This will also shrink down the size of the user's microservice by a significant amount, making it easily manageable by a small team, while still integrating the features of the user-progression and the purchase entity.

Here's the final diagram for our practice context:

.Practice microservices
image::10_Domains/TAD_10_Practice_Microservice.png[]

==== Assessment microservices ====
As always, let's start with the aggregates identified in our domain model. In the assessment context, we found only one aggregate, the campaign aggregate, which encapsulates all our entities within our domain. As you might have realized, this is way to big for a small team to handle, and we need to identify where we can divide our microservice.

I'm going to keep the assessor and the tags entity within the campaign microservice, simple because they are way too small to be separated in their own service. They are both very simple in nature, with close to no business logic. They are not valid candidates for a microservice on their own. I'm applying the same line of thoughts as for the practice microservices.

We are left with the candidates and the test entities. Both are great candidates, since they handle logic that are quite decoupled from the campaign itself. This is why I've decided to create a microservice for both of them. Here's the diagram:

.Assessment microservices
image::10_Domains/TAD_10_Assessment_Microservice.png[]

We also added our reports domain service as a microservice. It will be responsible for generating reports linked to a campaign. We are left with microservices that are small enough in size, but not too small. They are not too chatty, are not tightly coupled and can evolve independently.

==== Content microservices ====
Following the same logic as with the previous domains, we start from aggregates and we trim down each one of them, following some common sense and technical and business requirements:

.Content microservices
image::10_Domains/TAD_10_Content_Microservice.png[]

We can not divide our submission aggregate since it only has itself as entity. However, the content aggregate has component as a child entity, which itself has the validator entity as a child. I've decided to keep the content and component entity together, since they are very closely related, and content is nothing more than a composition of component, at least in this domain. They are very chatty, since every mutation and reads on a content will most likely trigger a similar event for one or multiple components. Keeping them together makes for a microservice of a reasonable size, that can be worked on by a small team, within the same logic.
We can, and should, create a separate microservice for the validators. Validators might look like a simple CRUD at first glance, but actually is way more complicated than that, since it can take multiple shapes depending of the type of component being validated. I would argue that most of the complexity in this aggregate is within this entity. It is also separated enough for another team to work on, although a good communication between the teams responsible of creating the content microservice and validator microservice will be required.

Just like before, we must not forget our runner domain service, which will become a microservice by itself. I'm not going into any details here, since the runner part of the system will have its own separate section.

==== Putting it all together ====
Now that we have defined all our microservices within each of our bounded contexts, let's take a look at the greater picture of our architecture:

.Complete architecture
image::10_Domains/10_Complete_Architecture.png[]

I would argue that a system-wide event related to major user mutation emerging from the account domain, such as a user being deleted for example, is needed for the other domains to act within their boundaries to take the actions it deems needed. However, since we can't use message queues, I will not dive further into this idea, since it is the most sensible way to implement this idea.

We also need communication between the submission microservice and the candidates and user microservices, since submission are linked to the user and candidate progression. To do so, I would also propose the use of message queues, where the submission service would publish messages whenever a new submission has been mutated, as it allows for a total decoupling of domains, and improve reliability since messages can be published even when they are no consumer able to handle the messages. It is the only way to do so without breaking boundaries. Any synchronous communication protocol would not fit this use case, so I will implement a message queue here, even if we are not allowed to do so. It makes too much sense to not use it. We will discuss this matter later in this paper.

There are multiple oversight, such as the runner service which is not as simple as it might look on the diagram, or how to handle user's authentication and authorization. Now that we have defined our contexts, domains and our microservices, let's tackle one of the problem we just mentioned: authentication and authorization.
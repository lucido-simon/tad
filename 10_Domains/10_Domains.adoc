= From domains to microservices =

== Introduction ==
It's important to recognize the way you design you microservices will be reflected on the quality of your application. Poorly divided microservices will result in poor performance, poor maintainability, poor developer experience, and overall a bad user experience. If your data is poorly isolated, it will span multiple microservices and create a integrity and consistency mess. Make microservices too big and you lose the benefits. Make microservices too small and you begin to overload your network infrastructure, increase costs, decrease maintainability and increase your risks of bugs. Whatever your implementation, a poorly designed infrastructure will cause headaches. Let's see how we can create a sensible microservice architecture, using Polycode as our use case.

The first step in decomposing your application into microservices is to understand the domain that it lives in. To make sure that everybody is on the same page, and to provide a common vocabulary for your engineers, marketing team, executive team, architects and whoever might be working on the project, we need to define the language that is used around your project.

== Ubiquitous Language ==
The ubiquitous language is a common vocabulary everybody involved in the project should define together and use to communicate. The goal is to make sure that everybody refers to the same concept when talking about the project, reducing confusion and misunderstanding, avoiding conflicts and unnecessary discussion.

As the Polycode team, we defined the following vocabulary for the Polycode project. Please take some time to read through it, to make sure your understanding is aligned with mine.


|===
| Word | Definition 
| Practice | A section of Polycode made to train users 
| Assessment | A section of Polycode made to evaluate user 
| Admin | A privileged user that have access and permission to manage all resources in Polycode. 
| User | Someone who has a Polycode account. 
| Candidate | A person who participate to a test or assessment. 
| Guest | Someone who doesn't have an account. 
| Captain | A user who manages a team. 
| Assessment Creator | A user who can edit or create assessment, and invite candidates. 
| Practice Creator / Content creator | A user who can edit or create his content. 
| Test | It is an ordered group of contents made to evaluate users. It has a grade, which is the total score divided by the total number of points in the set of contents. It is created by an assessment creator. 
| Campaign | Usage of a test on a group of candidates 
| Module | A grouping, possibly nested, holding contents and that can give points when fully completed. 
| Content | A content is a coherent group of components. The contents are organized in a tree structure. The modules are branches and the contents are leaves. In other words, unlike modules, a content can't contain modules or other contents. 
| Component | Its a small unit of what will be displayed to the end users. You must use components to build your content, components compose contents. Can be of multiple types, a markdown or an editor for example. 
| Hint | A hint is an item to help the user to finish a component in exchange for PolyPoints. 
| Item | Represents a purchasable resource. 
| Polypoints | A virtual money responsible of the gamification of Polycode. Polypoints can be used to buy items. The user and team leader boards are based on the number of Polypoints. Polypoints can be earned by completing contents or modules. 
| Runner | A service that executes code in a given language and returns the output (stdout and stderr). 
| Submittable | A component that can be submitted for validation by a user to the application. 
| Submission | A user's answer to a submittable. Can be validated through a validator.
| Team | Group of users. One of them is the team's captain. The team's Polypoint count is the sum of the Polypoints of its users. Team are ranked according to their Polypoints. 
| Validator | Validate users submission. 
| Tag | Keyword associated to a resource used for statistics and filtering.
| Purchase | Items that was bought by a user.
|===

== User stories
Now that we agree on the vocabulary, and that we clearly defined what are the meaning behind words in the scope of the Polycode application, we now need to define the features that needs to be available to all our users. This can be done using user stories. They define actions that someone should be able to do on the platform, giving context as why they want to do so. Defining why they want to do so tries to make sure we define features that makes sense, and to keep the end goal in sight.

Here are the user stories we came up with, based on our client specifications:

|===
| As a | I want to | In order to
| Guest | Create my account | Use the application functionalities
| User | Update my email | Recover my account if I was to change my email address
| User | Reset my password using my email | Recover my account if I was to forget my password
| User | Receive a welcome mail when I sign up | Be notified when my registration is completed
| User | Show my account details | To review my personal information
| User | Show other's details | To gather information about another user
| User | Change my username, my preferred programming language and my bio | Update personal information and settings if there was to change
| User | Delete my account | Delete my fingerprint on the Polycode application
| User | Connect to my account using my username and my password | Access the application's functionalities
| User | Logout of my account | Avoid non authorized access from a computer I used
| User | Create a new team | Gather a user group and participate to teams leader board
| Captain | Invite other users in my team | Grow my team
| Captain | Delete a member from my team | Remove a problematic member, for whatever reasons
| Captain | Give the captain role to another member of my team | Dispose of my role
| Captain | Delete my team | Delete this team's fingerprint on Polycode, for whatever reasons
| Captain | Change the name and the description of my team | Keeping the team's infos up to date
| User | Accept or decline a team invite | Join the team I want to join
| User | Leave a team | Not being associated to a certain group of user
| User | See my team's points | Follow my team progress
| User | See the teams leader board | See my team placement
| User | See the internal ranking of my team's members | See who participates the most in the team
| User | See the list of available exercises | Choose an exercise
| User | See the list of available modules | Choose a module
| User | See the sub-modules and exercises of a module | See the steps needed to complete the module
| User | See the list of available evaluations | Choose an evaluation to pass
| User | See the latest exercises / modules posted online | See the new content
| User | See the information of an exercise | Get information on the subject of an exercise
| User | See the information of a module | Get information on the subject of the module, the objective
| User | See the information of an evaluation | Get information on the subject of the evaluation, the objective
| User | See the statement of an exercise | Know the problem to be solved and the questions to answer before validating the concept
| User | Propose a solution to the exercise | Earn PolyPoints and progress in the associated module
| User | In the case of code to be written, execute an intermediate validator | Check if my code is correct for the validator in question
| User | Save the last solution that was the most successful | Take the code from a different device, at another time, to improve it
| User | Write (and modify) my code solution in an editor integrated into the exercise page (code exercise case) | Propose a solution to the exercise
| User | Add files to the editor | Organize my solution into multiple files
| User | Delete files in the editor | Organize the solution into multiple files
| User | Buy hints with PolyPoints | Better understand how to solve the exercise
| User | Follow my progress in each module | See what I completed, and what's still in progress
| User | See the global leader board users | Gain motivation to reach the top
| User | Take an evaluation | Get a certification
| User | Read the content of a course | Become competent on a subject
| Content Creator | Create an exercise, add markdown, a code editor, a QCM | Teach a new concept, check the knowledge of this concept with a question / code to be written
| Content Creator | Create a module | Organize exercises by major concept / theme
| Assessment Creator | Create an test | check the skill set of a user on something
| Content Creator | Add my exercises to a module I have created | Fill the content of a module with a coherent and organized set of elements
| Content Creator | Add submodules to a module | Fill the content of a module with a coherent and organized set of elements

| Content Creator | Delete a content I created | Fix a mistake or delete the existence of this content
| Content Creator | Delete a module I created | Fix a mistake or delete the existence of this module
| Assessment Creator | Delete a test I created | Fix a mistake or delete the existence of this test
| Assessment Creator | See the results of my test | Mark a candidate
| Admin | Promote a user to a creator | Add a new creator
| Admin | Promote a user to an admin | Add a new admin
| Admin | Fetch data of a user | See the personal information of a user
| Admin | Update user's data | Help recover and fix problems with a user account
| Admin | Delete a user | Remove access of a user
| Admin | Have a content creator or assessment creator permissions | Edit and manage existing content, if the need arise
| Admin | Have a user permissions | Use the site as a normal user
| Assessment Creator | Create a campaign | Test a set of candidates
| Assessment Creator | Add candidates via a web interface | Add candidates to my campaign
| Assessment Creator | Delete candidates via a web interface | Delete candidates to my campaign
| Assessment Creator | Add candidates via a web API | Add candidates to my campaign
| Assessment Creator | Delete candidates via a web API | Delete candidates to my campaign
| Assessment Creator | Add candidates via a CSV file | Add candidates to my campaign
| Assessment Creator | See results and stats of a campaign I created | Evaluate the candidates level
| Assessment Creator | Add tags to candidates | Group candidates
| Assessment Creator | Define a expiration time for my campaign | Close my campaign at a fixed time
| Candidate | Come back to a test, without losing my progress | Finish my test if I were to leave the app
| Assessment Creator | Define a limited time for each of my questions | Restrain the maximum time a candidate has for a question
| Assessment Creator | Define the points a question can give | Score candidates
| Candidate | Receive a mail to opt-in the campaign | Join or decline a campaign
| Candidate | Accept a campaign | Participate in a campaign
| Candidate | Decline a campaign | Not participate in a campaign, and notify the creator
| Assessment Creator | Edit my campaign | Fix mistakes or edit its content
| Assessment Creator | Define a beginning date for my campaign | Time frame my campaign
| Assessment creator | Manually send begin campaign mail to candidates | Customize the campaign access
| Candidate | Receive a email when I finished passing my test | Get a confirmation that my answers was taken into account
| Assessment Creator | Visualize the results by tag in a graph | Better visualize results
| Assessment Creator | Export summed up results as PDF | Save results in a synthetic way
| Assessment Creator | Export detailed results as PDS | Save results and have them available locally
| Assessment Creator | Compare candidates results via a excel document | Compare candidates
| Assessment Creator | Sort candidates by tags or results | Compare candidates using the criteria I want
|===

== Domain Driven Design (DDD) ==
Great! We now have defined a common language around the Polycode domain, and we also have explicitly defined the features and expected user interaction with our app. We now have a solid foundation to start thinking about the architecture of our application. In order to make this goal more achievable, and to actually come up with a sensible approach, we are going to design our architecture based on the functional needs of our applications. Starting high up in the mental model of relations between components of our application, diving deeper and deeper until we come up with an actual microservice architecture. This is called Domain Driven Design.

=== The origin ===
Domain-driven design (DDD) is a software development approach that focuses on the design and development of a system from the perspective of the business domain it operates in. It was first proposed by Eric Evans in his book __Domain-Driven Design: Tackling Complexity in the Heart of Software__ which was published in 2003. DDD is based on the idea that by better understanding the business domain and the underlying processes, it is possible to design and develop more effective software systems that can help organizations operate more efficiently and effectively. In his book, Eric Evans defines key component around this approach, as well as identifying and naming common patterns you often encounter in complex, business-logic-heavy domains. This book triggered several engineers and practitioners in this field, to add onto this idea.
As you might have realized, the origin of DDD is not rooted within the microservice world. It is a software design approach that can be applied more broadly, when developing software, although it suits particularly well our microservice architecture.

=== What is the goal ===
Why should we design our application this way ? Why not just dive right into developing microservices, creating new one every time it __feels__ like the right choice ?

Your intuition might be right, but several problems arise :

* Getting it right gets exponentially more difficult the more complex your domain is. Moreover, xref:costOfMicroservices[as mentioned in the introduction], if you have a simple architecture, microservice might not be the best fit for you.
* Even if you're right, you need to justify your choices. Intuition is not a justification.
* You need to document your architecture, and the steps you've taken to get to here. This is important for anyone joining your team, to truly understand the decisions that have been made, why the current state of this architecture is the way it is.
* If you're wrong, it's much more difficult to come back and rethink your design. You will have no base to work with. This won't be a revision of what you've made, it's starting from the ground up once again.

And if it looks to costly to fix your architecture or if you're too stubborn to realize that you've made a mistake, you will have to work around those errors, adding band-aid on top of band-aids, and you'll have a unreliable, under-performing, hard to maintain architecture. It is key to understand that the decisions you're making when designing your architecture will impact every line of code written.

The goal of domain-driven design (DDD) is to help developers create software that accurately reflects the business domain and can be easily understood and maintained by domain experts. By aligning the software with the needs and goals of the business, DDD helps ensuring that the software is able to effectively support the business and its operations.

=== Microsoft ===
I wanted to highlight the work done by the Microsoft engineers in documenting and creating a microservice architecture. Their architecture documentation is a great resource, and I've learnt most of what I'm applying through it. As a matter of fact, I will apply their process for creating a microservice application using a DDD approach. I **highly** suggest reading their documentation https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/[here] and https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis[here] for a better understanding of DDD. We will walk trough each step in this chapter, but having a deeper understanding that the very high level overview that I'm going to give through this paper is worth it. Note that, while going much deeper, the Microsoft documentation is not the bible of DDD, and you might want to read https://www.amazon.fr/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215[__Domain-Driven Design: Tackling Complexity in the Heart of Software__] instead.
Microsoft goes much more into details about where using DDD to define your architecture makes sense. There is a lot to say about DDD, and this is misaligned with the core goal of this chapter, which is to explain the thought-process I had when architecting Polycode.
